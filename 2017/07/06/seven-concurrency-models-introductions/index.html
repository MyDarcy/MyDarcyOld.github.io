<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Concurrency,Java,Parallel,读书笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="翻完了&amp;lt;&amp;lt;七周七并发模型&amp;gt;&amp;gt;，里面设计了七种并发模型，包括线程和锁，函数式编程，clojure分离标志和状态，actor模型，通信顺序进程 – Communicating Sequentail Processes(CSP), 数据级并行，Lambda架构. 但是其中有四章是Clojure和Exilir来展开的，没怎么细看．这里是简要总结一下吧．">
<meta name="keywords" content="Concurrency,Java,Parallel,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="七并发模型简要介绍">
<meta property="og:url" content="http://yoursite.com/2017/07/06/seven-concurrency-models-introductions/index.html">
<meta property="og:site_name" content="darcy he">
<meta property="og:description" content="翻完了&amp;lt;&amp;lt;七周七并发模型&amp;gt;&amp;gt;，里面设计了七种并发模型，包括线程和锁，函数式编程，clojure分离标志和状态，actor模型，通信顺序进程 – Communicating Sequentail Processes(CSP), 数据级并行，Lambda架构. 但是其中有四章是Clojure和Exilir来展开的，没怎么细看．这里是简要总结一下吧．">
<meta property="og:updated_time" content="2017-07-06T11:42:43.091Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="七并发模型简要介绍">
<meta name="twitter:description" content="翻完了&amp;lt;&amp;lt;七周七并发模型&amp;gt;&amp;gt;，里面设计了七种并发模型，包括线程和锁，函数式编程，clojure分离标志和状态，actor模型，通信顺序进程 – Communicating Sequentail Processes(CSP), 数据级并行，Lambda架构. 但是其中有四章是Clojure和Exilir来展开的，没怎么细看．这里是简要总结一下吧．">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/06/seven-concurrency-models-introductions/"/>





  <title>七并发模型简要介绍 | darcy he</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?594cf3672b18c8c9a97689d1dfffaa39";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">darcy he</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">求知 孤勇 温柔</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/seven-concurrency-models-introductions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="darcy.q.cs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/self.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="darcy he">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">七并发模型简要介绍</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T19:33:46+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/06/seven-concurrency-models-introductions/" class="leancloud_visitors" data-flag-title="七并发模型简要介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>翻完了&lt;&lt;七周七并发模型&gt;&gt;，里面设计了七种并发模型，包括线程和锁，函数式编程，clojure分离标志和状态，actor模型，通信顺序进程 – Communicating Sequentail Processes(CSP), 数据级并行，Lambda架构. 但是其中有四章是Clojure和Exilir来展开的，没怎么细看．这里是简要总结一下吧．</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>并发：<strong>同一时间应对(dealing with)多件事情的能力</strong></li>
<li>并行：<strong>同一时间动手做(doing)多件事情的能力</strong></li>
</ul>
<p>并发程序的执行通常是不确定的，其结果依赖于事件时序．对于真正的并发程序，不确定性是其与生俱来且伴随始终的属性．而并行程序可能是确定的．</p>
<ul>
<li>并行架构<ul>
<li>位级并行：32位，64位</li>
<li>指令级并行：流水线，乱序，猜测执行</li>
<li>数据级并行: SIMD</li>
<li>任务级并行: 多处理器模型</li>
</ul>
</li>
</ul>
<hr>
<h2 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h2><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><ul>
<li>线程和锁模型其实是对底层硬件运行过程的形式化，这既是这种模型的最大优点，也是这种模型的最大缺点．</li>
<li><p>线程和锁模型的三个危害</p>
<ul>
<li><strong>竞态条件</strong>：代码行为取决于各操作的时序(常用同步来消除竞态条件)</li>
<li><strong>内存可见性</strong>: 何时一个线程对内存的修改对另一个线程可见．(锁和volatile来保证可见性)</li>
<li><strong>死锁</strong>: 多把锁加锁顺序不当导致各个线程都阻塞而不能继续执行的情况．(避免在持有锁的同时调用自己一无所知的方法,即外星方法．因为这就可能导致在加锁顺序一无所知的情况下使用两把锁而导致发生死锁)</li>
</ul>
</li>
<li><p>Java内存模型如何保证对象初始化是线程安全的?是否必须通过加锁才能在线程之间安全的公开对象?</p>
<ul>
<li>JVM在类的<strong>初始化阶段</strong>（即在Class被加载后，且被线程使用之前），会执行类的初始化。在<strong>执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化</strong>.</li>
<li>新的 JMM 还寻求提供一种新的初始化安全性保证——只要对象是正确构造的（意即不会在构造函数完成之前发布对这个对象的引用，换句话说，不要让其他线程在其他地方能够看见一个构造期间的对象引用），然后所有线程都会看到在构造函数中设置的<code>final</code>字段的值，不管是否使用同步在线程之间传递这个引用。而且，所有可以通过正确构造的对象的<code>final</code>字段可及的变量，如用一个<code>final</code>字段引用的对象的<code>final</code>字段，也保证对其他线程是可见的。这意味着如果<code>final</code>字段包含，比如说对一个 LinkedList 的引用，除了引用的正确的值对于其他线程是可见的外，这个<code>LinkedList</code>在构造时的内容在不同步的情况下，对于其他线程也是可见的。</li>
<li>在讲了如上的这段之后，如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），你希望保证这个对象被其他线程正确的查看，你仍然需要使用同步才行。</li>
</ul>
</li>
<li><p>“双重检查锁模式”（double-checked locking）以及为什么称之为反模式???</p>
<ul>
<li>关键在于：<strong>指令重排序导致在多线程情况下，其他线程可能访问到未初始化的对象</strong>。</li>
<li>解决方案有二：用volatile修饰instance对象；采用Initialization On Demand Holder idiom方案，即基于类的初始化方案（关键是JVM在初始化类的时候需要获取一把锁）。</li>
<li>选择方法：如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。</li>
</ul>
</li>
</ul>
<h3 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h3><ul>
<li><p>ReentranLock 和 Atomic原子类</p>
<ul>
<li>可以在线程持有锁的时候中断锁</li>
<li>可以设置线程获取锁的超时事件</li>
<li>按任意顺序来获取和释放锁</li>
<li>条件等待</li>
<li>atomic实现lock-free无锁操作．</li>
</ul>
</li>
<li><p>ReentrantLock创建时可以设置一个描述公平性的变量。什么是“公平”的锁？何时适合使用公平锁？使用非公平的锁会怎样？</p>
<ul>
<li>如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的；反之，则是非公平锁。</li>
<li>公平锁的性能不如非公平锁——公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配；另一方面，公平锁可以防止“饥饿”情况的产生，在以TPS为唯一指标的场景下，可以考虑使用公平锁。</li>
</ul>
</li>
<li><p>什么是ReentrantReadWriteLock？它与ReentrantLock有什么区别？适用于什么场景？</p>
<ul>
<li>ReentrantReadWriteLock的中文名称是读写锁，在多线程场景中，如果没有写线程在操作模板对象，读写锁允许多个读线程同时读。当对于某个数据结构的操作<strong>主要是读操作而只有少量的写操作时</strong>，就非常适合使用ReentrantReadWriteLock。</li>
</ul>
</li>
<li><p>什么是“虚假唤醒”（<code>spurious wakeup</code>）？什么时候会发生虚假唤醒？为什么符合规范的代码不用担心虚假唤醒？<br>（1）线程有可能在没有调用过notify()和notifyAll()的情况下醒来；<br>（2）查看如下代码，doWait方法中发生了虚假唤醒——等待线程即使没有收到正确的信号，也能够执行后续的操作。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify2</span></span>&#123;</div><div class="line"></div><div class="line">MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line"><span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">    <span class="keyword">if</span>(!wasSignalled)&#123;</div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        myMonitorObject.wait();</div><div class="line">       &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//clear signal and continue running.</span></div><div class="line">    wasSignalled = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">    wasSignalled = <span class="keyword">true</span>;</div><div class="line">    myMonitorObject.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）<strong>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里</strong>。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</div><div class="line"></div><div class="line">MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line"><span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">    <span class="keyword">while</span>(!wasSignalled)&#123;</div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        myMonitorObject.wait();</div><div class="line">       &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//clear signal and continue running.</span></div><div class="line">    wasSignalled = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">    wasSignalled = <span class="keyword">true</span>;</div><div class="line">    myMonitorObject.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>什么是AtomicIntegerFieldUpdater？它与AtomicInteger有什么区别？适用于什么场景？<br>（1）<strong>AtomicIntegerFieldUpdater用于保证已经new出来的实例的原子性</strong>，AtomicInteger用于构造具备原子性的Integer实例。<br>（2）使用第三方库的时候，如果需要给第三方库提供的对象增加原子性，则使用AtomicIntegerFieldUpdater。</li>
</ul>
<h3 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h3><p><strong>总结</strong></p>
<ul>
<li>使用线程池而不是直接创建线程</li>
<li>使用CopyOnWriteArrayList 避免使用外星方法导致的死锁问题</li>
<li>使用ArrayBlockingQueue来使得生产者和消费者高效协作</li>
<li>ConcurrentHashMap提供了更好的并发访问</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li><p>Fork/Join和线程池的区别，以及分别适用的场景</p>
<ul>
<li>ForkJoinPool 相比于ThreadPoolExecutor，还有一个非常重要的特点（优点）在于，ForkJoinPool具有 <strong>Work-Stealing （工作窃取）</strong>的能力。所谓 Work-Stealing，在 ForkJoinPool 中的实现为：<strong>线程池中每个线程都有一个互不影响的任务队列</strong>（双端队列），线程每次都从自己的任务队列的队头中取出一个任务来运行；如果某个线程对应的队列已空并且处于空闲状态，而其他线程的队列中还有任务需要处理但是该线程处于工作状态，那么空闲的线程可以从其他线程的队列的队尾取一个任务来帮忙运行 —— 感觉就像是空闲的线程去偷人家的任务来运行一样，所以叫 “工作窃取”。</li>
<li>Work-Stealing 的适用场景是不同的任务的耗时相差比较大，即某些任务需要运行较长时间，而某些任务会很快的运行完成，这种情况下用 Work-Stealing 很合适；但是如果任务的耗时很平均，则此时 Work-Stealing 并不适合，因为窃取任务时也是需要抢占锁的，这会造成额外的时间消耗，而且每个线程维护双端队列也会造成更大的内存消耗。所以<code>ForkJoinPool</code>并不是<code>ThreadPoolExecutor</code>的替代品，而是作为对 ThreadPoolExecutor 的补充。 </li>
<li>ThreadPoolExecutor 只能执行 Runnable 和 Callable 任务，而 ForkJoinPool 不仅可以执行 Runnable 和 Callable 任务，还可以执行 Fork/Join 型任务 <strong>ForkJoinTask</strong> 从而满足并行地实现分治算法的需要；</li>
<li>ThreadPoolExecutor 中任务的执行顺序是按照其在共享队列中的顺序来执行的，所以后面的任务需要等待前面任务执行完毕后才能执行，而 ForkJoinPool 每个线程有自己的任务队列，并在此基础上实现了 Work-Stealing 的功能，使得在某些情况下 ForkJoinPool 能更大程度的提高并发效率。</li>
</ul>
</li>
<li><p>CountDownLatch和CyclicBarrier的区别??</p>
</li>
</ul>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.<br>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p>
<p>从javadoc的描述可以得出：<br>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；<br>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。</p>
<p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。<br>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
</blockquote>
<h3 id="线程和锁模型优缺点"><a href="#线程和锁模型优缺点" class="headerlink" title="线程和锁模型优缺点"></a>线程和锁模型优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>线程和锁模型更接近于本质– 近似于对硬件工作方式的形式化，正确使用时候，效率很高．而且也能解决从小到大不同粒度的问题．</li>
<li>大多数语言支持．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>没有为并行提供直接的支持，不支持分布式内存</li>
<li>难于测试，很多时候我们并不知道自己在坑中，bug难以重现．</li>
<li>可维护性较差</li>
</ul>
<p><strong>基本规则</strong></p>
<ul>
<li>访问共享变量需要同步</li>
<li>获取多把锁时候需要按照全局固定的顺序</li>
<li>持有锁的时候避免调用外星方法</li>
</ul>
<hr>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote>
<p>函数式编程的好处由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是<strong>不可变性</strong>带来的。没有可变的状态，函数就是<strong>引用透明(Referential transparency)的和没有副作用(No Side  Effect)</strong>。</p>
<p>一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p>
<p>不变性带来的另一个好处是：由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称多处理器（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。</p>
</blockquote>
<h3 id="对状态的理解"><a href="#对状态的理解" class="headerlink" title="对状态的理解"></a>对状态的理解</h3><ul>
<li>们再来看看函数式编程当中的纯函数（Pure Function）的定义:</li>
</ul>
<blockquote>
<p>In computer programming, a function may be considered a pure function if both of the following statements about the function hold:<br>The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or between different executions of the program, nor can it depend on any external input from I/O devices (usually—see below).<br>Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below).</p>
</blockquote>
<ul>
<li>纯函数即为函数式编程所强调的函数，上述两点可翻译为：<ul>
<li><strong>不依赖外部状态</strong></li>
<li><strong>不改变外部状态</strong></li>
</ul>
</li>
</ul>
<p>所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解，时间和空间。</p>
<p><strong>时间</strong></p>
<ul>
<li>变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。</li>
<li>时间的武器是变化，是赋值，赋予变量新的值，在不可预知的未来埋下隐患。</li>
<li>一旦有了赋值操作，时间就找到了空隙，可以对我们代码的执行产生影响。或许是在此刻，或许是明天，或许是在appDidFinishLaunch，或许是在didReceiveMemoryWarning。每一个赋值操作都是一颗种子，可以结出新feature或者新bug。</li>
<li>变量会随着时间变化，有状态的函数也会随着时间的流动产生不同的输出，Pure Function却是对时间免疫的，纯函数没有状态，无论站在多长的时间跨度去执行一个纯函数，它所输出的结果永远不会变，从这一角度看，纯函数处于永恒的静止状态。</li>
</ul>
<p><strong>空间</strong></p>
<ul>
<li><p>如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。</p>
</li>
<li><p>Pure Function同样是对空间免疫的，无论多少个线程同时执行一个纯函数，纯函数总是产生相同的输出，而且不会对外部环境产生任何干扰。</p>
</li>
<li><p>多线程的bug调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。</p>
</li>
</ul>
<p><strong>变量和状态</strong></p>
<ul>
<li>一旦一个变量开始与=打交道，一旦变量的值会发生变化，我们就可以说这个变量有了状态。或者我们可以说，<strong>有=就有状态</strong>。</li>
<li>函数式编程当中的函数f(x)强调无状态，其实是强调将状态锁定在函数的内部，一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，我前面说过<strong>变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量</strong>。</li>
</ul>
<h3 id="函数式编程优缺点"><a href="#函数式编程优缺点" class="headerlink" title="函数式编程优缺点"></a>函数式编程优缺点</h3><ul>
<li>在线程和锁模型中，隐藏的竞态条件并不是来自问题本身的不确定性，而是隐藏于解决方案的细节中．</li>
<li>函数式编程具有引用透明性，因此可以随意改变其执行顺序，而不会对最终结果造成影响．所以就可以让相互独立的函数并行执行．</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>程序是按照预想的方式运行的；实现相同的功能，函数式编程可能更简洁，也更容易测试．</li>
<li><strong>引用透明性</strong>，所以很容易的将程序<strong>并行化</strong>，或者在<strong>并发</strong>环境下使用这个解决方案．而且函数式代码使用<strong>不可变状态</strong>，大部分存在于线程和锁的并发bug都不会存在了．</li>
<li>健壮性，可拓展性，可维护性.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>相比于等价的命令式代码，效率可能损失较大．</li>
</ul>
<hr>
<h2 id="Clojure分离标识别和状态"><a href="#Clojure分离标识别和状态" class="headerlink" title="Clojure分离标识别和状态"></a>Clojure分离标识别和状态</h2><p>里面的东西懒得看了．</p>
<h3 id="Clojure分离标识别和状态优缺点"><a href="#Clojure分离标识别和状态优缺点" class="headerlink" title="Clojure分离标识别和状态优缺点"></a>Clojure分离标识别和状态优缺点</h3><ul>
<li>Clojure可以发挥函数式语言的特点，编写出具有<strong>引用透明性和无副作用的代码</strong>．对于某些问题场景需要对某些可变状态进行维护，Clojure又提供了很多<strong>并发安全的可变数据类型</strong>．</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>Clojure的持久化数据结构将可变标识和状态分离开来．解决了使用锁的方案的大部分缺点．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>不支持分布式，无法提供容错性</strong>；但是可以用Akka等框架来弥补这些缺陷．</li>
</ul>
<hr>
<h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><ul>
<li>actor模型是一种适用性非常好的通用并发编程模型，可以应用于共享内存架构和分布式内存架构．也提供很好的容错性．</li>
<li>函数式编程不使用可变状态，也就避免了共享可变状态带来的问题．而使用actor模型则保留了可变状态，但是不进行共享．</li>
<li>actor类似OO中的对象– 封装了状态; 并通过消息和其他actor通信．和OO式的通过方法调用来传递消息不同，actor之间的消息传递是真实的在传递消息．</li>
</ul>
<h3 id="D1-1"><a href="#D1-1" class="headerlink" title="D1"></a>D1</h3><ul>
<li>消息并不是直接发送到一个actor，而是发送到一个信箱中．actor都是以自己的步调运行，发送消息时候不会被阻塞．actor以信箱接收消息的顺序来依次处理消息．</li>
<li>多个actor可以同时运行，不共享状态，通过向信箱异步发送消息来进行通信．因此<strong>一个actor的崩溃不太会殃及到其他的actor</strong>，尤其重要的是一个actor的崩溃不会影响到其管理者，这样管理者才会正确的处理此次崩溃．</li>
</ul>
<h3 id="Actor模型的优缺点"><a href="#Actor模型的优缺点" class="headerlink" title="Actor模型的优缺点"></a>Actor模型的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>消息传输和封装：虽然多个actor可以同时运行，但是它们并<strong>不共享状态</strong>，而且在单个actor中所有事件都是串行执行的．所以关于并发，只需要关注多个actor之间的消息流即可．</li>
<li>容错：actor模型天生具有<strong>容错性</strong>．</li>
<li>分布式编程：actor模型<strong>支持共享内存和分布式内存模型</strong>．这样actor就可以解决任何规模的问题，而不是将问题局限在一个系统内解决．actor也可以处理地理分布的问题．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>actor模型仍然有死锁这类问题，以及actor模型自己的问题，比如信箱溢出了．</li>
<li>actor模型对并行也没有直接支持．需要通过并发的技术来构造并行的方案，这样就引入了不确定性．</li>
<li>actor共享状态，仅能通过消息传递来进行交流．所以不太适合实施细粒度的并行．</li>
</ul>
<hr>
<h2 id="顺序进程通信"><a href="#顺序进程通信" class="headerlink" title="顺序进程通信"></a>顺序进程通信</h2><ul>
<li>CSP: Communicating Sequential Processes</li>
<li>actor模型的程序是由独立的，并发执行的实体(Actor)组成，这些实体之间通过发送消息进行通信．<strong>每个actor都有一个信箱，用于保存已经收到但是尚未被处理的消息</strong>．</li>
<li>和actor模型相似，通信顺序进程（CSP）也是由独立的，并发执行的是实体所组成，实体之间也是通过发送消息进行通信．两种模型的重要差别是：CSP模型不关注发送消息的实体，而是<strong>关注发送消息使用的通道（Channel）</strong>. Channel是第一类对象，它不像actor那样和信箱是紧耦合的，而是可以单独的创建和读写，并在进程之间传递．</li>
</ul>
<h3 id="D1-2"><a href="#D1-2" class="headerlink" title="D1"></a>D1</h3><ul>
<li>一个<strong>channel就是一个线程安全的队列</strong>．任何任务只要持有channel的引用，就可以向其发送消息，从中接收消息．而在actor模型中，消息是从指定的actor发往指定的另一个actor的．使用channel发送方并不知道谁是接收者，而接收者也不知道谁是发送者．</li>
<li>根据指定有无缓冲，可以创建异步和同步的channel.在Go语言中，不可用向nil通道中发送消息．不可用在接收端关闭通道．不可以关闭一个已经关闭的通道．从已经关闭的通道中接收已经缓存的数据或者没有缓存数据时候返回零值数据．</li>
<li>三种缓冲区类型：阻塞型（blocking）, 丢弃新值型，丢弃旧值型．</li>
</ul>
<h3 id="CSP模型的优缺点"><a href="#CSP模型的优缺点" class="headerlink" title="CSP模型的优缺点"></a>CSP模型的优缺点</h3><ul>
<li>虽然acotr模型和CSP模型都是由并发的执行单元构成，执行单元之间都是使用消息进行通信．但是侧重点不一样．</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>和Actor模型先比，CSP模型的最大优点是灵活性：使用Actor模型时候，<strong>负责通信的媒介和执行单元是紧耦合的</strong> – 每个actor都有一个信箱．而使用CSP模型时，<strong>channel是第一类对象．可以被独立的创建，写入读取数据．在不同的执行单元之间传递</strong>．</li>
<li>在Actor模型中，生产者和消费者还是耦合在一起的．也可以使用actor模型实现消息通信队列．但是actor模型本身就使用了队列．再用它来实现基础的消息通信队列优点画蛇添足．</li>
<li>有的CSP实现使用了控制反转技术，提高了异步程序的效率，也可以改进应用回调模型的问题域．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>基于CSP模型对<strong>分布式和容错性</strong>支持不太好</li>
<li>CSP模型和线程模型，Actor模型一样，也容易收到死锁影响（记得没有close　channel的时候抛出过几次这样的错误）．</li>
<li>CSP模型不直接支持<strong>并行</strong>．并行需要在并发的基础之上构建．引入了不确定性．</li>
</ul>
<hr>
<h2 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h2><h3 id="图形处理和数据并行"><a href="#图形处理和数据并行" class="headerlink" title="图形处理和数据并行"></a>图形处理和数据并行</h3><ul>
<li>游戏场景中，施加在数据上的操作都是相对简单的向量操作或者矩阵操作，这样的场景非常适合于数据并行 – 多个计算资源会在不同的数据上并行的施加同样的操作．</li>
<li>数据并行可以通过流水线和多ALU(算术逻辑单元)来实现．</li>
<li>多ALU: 只要搭配足够宽的内存总线，多个ALU就可以同时获取多个操作数，这样施加在大量数据上的运算可以并行了．GPU的内存总线通常有256位宽或者更宽．也就是一次就可以获取４个或者更多的64位的浮点数．</li>
<li>同步屏障(barrier)是一种同步手段，用来协调多个工作项对于局部内存的使用．如果工作组中的一个工作项执行了barrier()，那么该工作组其他工作项必须都要执行相同的barrier()才能从当前节点往下执行．</li>
</ul>
<h3 id="数据并行模型的优缺点"><a href="#数据并行模型的优缺点" class="headerlink" title="数据并行模型的优缺点"></a>数据并行模型的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>数据并行非常适用于处理大量的数据，尤其适用于科学计算，工程计算和仿真．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>数值领域内，数据并行模型很有用，但是非数值领域内，其表现一一般．</li>
<li>跨平台很难．调优要求高．</li>
</ul>
<hr>
<h2 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h2><ul>
<li>Lambda架构即使用了大规模数据批处理的<strong>MapReduce技术</strong>，也使用了可以快速处理数据的<strong>流处理技术</strong></li>
<li>Lambda架构也使用了数据并行技术．它可以将数据和计算分布到几十上百台机器构成的集群上进行．解决了之前大数据而无法解决的难题．也可以构建出对硬件和人为错误进行容错的系统．</li>
<li>批处理系统使用MapReduce批处理技术可以从历史数据中对批处理视图进行预计算．这种计算效率高延迟也高．所以增加了加速层，使用流处理等低延迟技术从接收到的新数据中计算实时视图．合并这两种试图，就可以得到最终的结果．</li>
</ul>
<h3 id="Hadoop基础"><a href="#Hadoop基础" class="headerlink" title="Hadoop基础"></a>Hadoop基础</h3><ul>
<li>MapReduce任务由两个主要的组件构成，包括mapper和reducer. mapper负责将某种输入格式有映射为许多的键值对，reducer则负责将这些键值对转换为最终的输出格式．</li>
<li>输入通常是多个大的文本构成，Hadoop对这些文件进行分片，并将这些分片发送给一个mapper．mapper将输出一系列的键值对．Hadoop再将这些键值对发送给reduder.</li>
<li>一个mapper产生的键值对可以发送给多个reducer.键值对的键决定了哪个reducer会接收这个键值对．Hadoop确保具有相同键的键值对都会发送到同一个reducer进行处理（shuffle阶段）</li>
</ul>
<p><strong>Hadoop优势</strong></p>
<ul>
<li>速度优势</li>
<li>Hadoop天生就具有处理错误和从错误中恢复的能力．</li>
<li>Hadoop使用分布式的HDFS问题系统，其具备容错能力．可以存储冗余的数据</li>
<li>Hadoop处理过程中产生的键值对存储在HDFS上，这样其处理能力不受内存限制．</li>
</ul>
<p><strong>数据的不变性和并行计算非常适合搭配在一起</strong>，　数据不变时候，多个线程就可以并行的访问数据，而不用担心相互之间的作用．也可以复制副本，而在副本上操作而不用担心数据会过期．</p>
<h3 id="Storm系统"><a href="#Storm系统" class="headerlink" title="Storm系统"></a>Storm系统</h3><ul>
<li>Hadoop主要负责批处理，Storm主要负责实时的处理．</li>
<li>Storm处理的是元组的流，元素由spout(出水管)组件创建，并由bolt(螺栓)组件进行处理．bolt也会输出元组，用流将spout和bolt连接在一起，就形成了topology拓扑结构．</li>
<li>bolt可以消费多个流，一个流也可以被多个bolt消费．构成了一个有向无环图.</li>
<li>spout和bolt都是并行化和分布式的．spout和bolt不仅相互之间是并行的．而且其内部也是并行的．每一个个体的内部都是由很多的worker实现的．流水线上每个节点的worker都可以向下游节点的任意一个worker发送元组．worker也是分布式的．</li>
<li>Storm的优雅之处在于：不需要特别关注分布式，只需要定义号topology，Storm就会向节点分配好worker．并且保证发送的元组可达．</li>
</ul>
<p><strong>容错性</strong></p>
<ul>
<li>将一个spout和bolt的多个worker分布到多台计算机上的主要原因是因为容错性．如果在集群中的某一台计算机发生故障，topology就会将元组发给仍然存活的计算机．这样topology就可以继续运行．</li>
<li>Storm会监视元组之间的依赖，如果一个元组没有完成，Storm会将其依赖的spout元组置为失败并进行重试．也就是说Storm会默认采用＂<strong>至少会执行一次</strong>＂的处理策略．应用必须知道这个事实：元组可能被重试，直到结果正确．</li>
</ul>
<p><strong>Storm的总结</strong></p>
<ul>
<li>Storm实时的处理元组，元组由spout创建，由bolt处理，由topology调度．</li>
<li>spout和bolt都包含多个worker，这些worker并行执行，且分布在集群的多个节点上．</li>
<li>Storm默认采用＂至少执行一次＂策略，bolt需要处理元组被重试的情况．</li>
</ul>
<h3 id="Lambda模型的优缺点"><a href="#Lambda模型的优缺点" class="headerlink" title="Lambda模型的优缺点"></a>Lambda模型的优缺点</h3><ul>
<li>Lambda架构将处理架构分布到了集群上，既改进了性能，也可以对硬件故障进行容错．</li>
<li>Storm的元组流类似actor模型和CSP模型的消息机制．</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>Lambda架构主要用于解决大规模的数据问题．这些问题采用传统的架构难以处理．Lambda架构非常适合于报表和分析．</li>
<li>基于分布式系统构建；容错能力强．</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>除非数据达到一定的量级，否则成本将高于收益．</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.jianshu.com/p/47ade7eedcfe" target="_blank" rel="external">《七周七并发模型》阅读笔记（一）</a></li>
<li><a href="https://segmentfault.com/a/1190000008140126" target="_blank" rel="external">Java 多线程（5）：Fork/Join 型线程池与 Work-Stealing 算法</a></li>
<li><a href="http://www.jianshu.com/p/bce9f156080f" target="_blank" rel="external">java并发编程之CountDownLatch与CyclicBarrier</a></li>
<li><a href="https://www.zhihu.com/question/30190384" target="_blank" rel="external">为什么这两年函数式编程又火起来了呢？</a></li>
<li><a href="http://mrpeak.cn/blog/functional/" target="_blank" rel="external">iOS与函数式编程</a>如何深入浅出地解释并发模型中的 CSP 模型？</li>
<li><a href="https://www.zhihu.com/question/26192499/answer/46815754" target="_blank" rel="external">如何深入浅出地解释并发模型中的 CSP 模型？</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Concurrency/" rel="tag"># Concurrency</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Parallel/" rel="tag"># Parallel</a>
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/26/golang-about-tests-toolchains/" rel="next" title="Golang-测试和工具链介绍">
                <i class="fa fa-chevron-left"></i> Golang-测试和工具链介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/06/algorithm-is-list-palindromicList/" rel="prev" title="链表是否是回文">
                链表是否是回文 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/self.jpg"
               alt="darcy.q.cs" />
          <p class="site-author-name" itemprop="name">darcy.q.cs</p>
           
              <p class="site-description motion-element" itemprop="description">心怀孤勇.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/MyDarcy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/70670266" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  douban
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/frobisher27149" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.zhenlanghuo.top/" title="zhenlang huo" target="_blank">zhenlang huo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://xawei.me/" title="xinan wei" target="_blank">xinan wei</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和锁"><span class="nav-number">2.</span> <span class="nav-text">线程和锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#D1"><span class="nav-number">2.1.</span> <span class="nav-text">D1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D2"><span class="nav-number">2.2.</span> <span class="nav-text">D2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D3"><span class="nav-number">2.3.</span> <span class="nav-text">D3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和锁模型优缺点"><span class="nav-number">2.4.</span> <span class="nav-text">线程和锁模型优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-number">3.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对状态的理解"><span class="nav-number">3.1.</span> <span class="nav-text">对状态的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式编程优缺点"><span class="nav-number">3.2.</span> <span class="nav-text">函数式编程优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clojure分离标识别和状态"><span class="nav-number">4.</span> <span class="nav-text">Clojure分离标识别和状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Clojure分离标识别和状态优缺点"><span class="nav-number">4.1.</span> <span class="nav-text">Clojure分离标识别和状态优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Actor"><span class="nav-number">5.</span> <span class="nav-text">Actor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#D1-1"><span class="nav-number">5.1.</span> <span class="nav-text">D1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Actor模型的优缺点"><span class="nav-number">5.2.</span> <span class="nav-text">Actor模型的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序进程通信"><span class="nav-number">6.</span> <span class="nav-text">顺序进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#D1-2"><span class="nav-number">6.1.</span> <span class="nav-text">D1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSP模型的优缺点"><span class="nav-number">6.2.</span> <span class="nav-text">CSP模型的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据并行"><span class="nav-number">7.</span> <span class="nav-text">数据并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图形处理和数据并行"><span class="nav-number">7.1.</span> <span class="nav-text">图形处理和数据并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据并行模型的优缺点"><span class="nav-number">7.2.</span> <span class="nav-text">数据并行模型的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda架构"><span class="nav-number">8.</span> <span class="nav-text">Lambda架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hadoop基础"><span class="nav-number">8.1.</span> <span class="nav-text">Hadoop基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Storm系统"><span class="nav-number">8.2.</span> <span class="nav-text">Storm系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda模型的优缺点"><span class="nav-number">8.3.</span> <span class="nav-text">Lambda模型的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">darcy.q.cs</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nDVrc1Rvjlwx4V9XScsLSm9q-gzGzoHsz", "4ONqgToWREwRHxcX9qRXFhlL");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
